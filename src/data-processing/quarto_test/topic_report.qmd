---
title: "Progression Report"
format: html
editor: visual
---

This file is used to visually represent the current status of coding data. Included are the reliability scores for coders and topics.

## Data

Raw data can be found in the [data folder](https://github.com/vanatteveldt/issuepositions/tree/main/data) folder and code used to generate statistics and plots is available in [topic_status_report](https://github.com/vanatteveldt/issuepositions/blob/main/src/data-processing/topic_status_report.R) file.

```{r}
#| messages: false
#| warnings: false
#| output: false

library(tidyverse)
library(irr)
library(ggplot2)
library(readr)
library(kableExtra)
library(simplermarkdown)
library(knitr)

```

```{r}
#| echo: true
#| messages: false
#| warnings: false
#| output: false
all_units <- read_csv("~/VU/issuepositions/data/intermediate/coded_units.csv")
gpt_issues_all <- read_csv("~/VU/issuepositions/data/intermediate/gpt_issues_all.csv") |>
  filter(logprob >= -5)

```


```{r}
#| echo: false
#| messages: false
#| warnings: false
#| output: false

CODERS <- c("AvH","MR","WA","JF","NR","S", "ING","NK","SH","OY","KN","NPR","JE","AM")

# # Identify the abbreviations of coders that are present in all_units
present_coders <- intersect(CODERS, names(all_units))

# # Convert only the columns for the present coders to numeric values
all_units_numeric <- all_units |> 
  mutate(across(all_of(present_coders), ~ as.numeric(factor(.))))

# Overall Reliability calculation
alpha <- function(all_units_numeric) {
  select(all_units_numeric, all_of(present_coders)) |>
    # Prepare numeric data as a matrix for Krippendorff calculation
    as.matrix() |>
    t() |>
    irr::kripp.alpha(method="nominal")
}

# Pairwise reliability
pairwise_alpha_new <- function(all_units_numeric) {
  coders <- present_coders
  result <- tibble(coder1 = character(), coder2 = character(), alpha = numeric())
  
  for (i in 1:(length(coders) - 1)) {
    for (j in (i + 1):length(coders)) {
      coder1 <- coders[i]
      coder2 <- coders[j]
      
      
      # Filter data to include only coder columns
      sub_data <- all_units_numeric |>
        select(all_of(c(coder1, coder2))) |>
        na.omit()
      
      # Check if there are enough data points for calculation
      if (nrow(sub_data) > 1) {
        
        # Calculate Krippendorff's alpha for the pair
        tryCatch({
          alpha_value <- irr::kripp.alpha(t(as.matrix(sub_data)), method = "nominal")
          # Store results
          result <- result |>
            bind_rows(tibble(coder1 = coder1, coder2 = coder2, alpha = alpha_value$value))
        }, error = function(e) {
          message("Error calculating alpha for ", coder1, " and ", coder2, ": ", e$message)
        })
      } else {
        message("Insufficient data for calculating alpha between ", coder1, " and ", coder2)
      }
    }
  }
  
  return(result)
}


overall_kripp_alpha <- alpha(all_units_numeric)

pairwise_kripp_alpha <- pairwise_alpha_new(all_units_numeric)


#plotting reliability values between coders

plot_pairwise_kripp_alpha <- function(pairwise_kripp_alpha) {
  # Convert coder columns to factors to ensure correct plotting order
  pairwise_kripp_alpha <- pairwise_kripp_alpha %>%
    mutate(coder1 = factor(coder1, levels = unique(c(coder1, coder2))),
           coder2 = factor(coder2, levels = unique(c(coder1, coder2))))
  
  # Plot heatmap
  ggplot(pairwise_kripp_alpha, aes(x = coder1, y = coder2, fill = alpha, label=round(alpha,2))) +
    geom_tile(color = "white") +
    geom_text(color = "white") +
    scale_fill_gradient2(low = "darkred", high = "darkgreen", mid = "gold", midpoint = 0.5,
                         name = "Krippendorff's Alpha") +
    labs(title = "Pairwise Krippendorff's Alpha Between Coders",
         x = "",
         y = "") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none") +
    coord_fixed()
}

# create topic info table

# count units per topic coded


topic_count <- function(df, topic_name){
  # count number of rows containing a topic
  if ((nrow(df[df$topic == topic_name,])==0)){
      return (0)}
  else{
    return (nrow(df[df$topic == topic_name,]))}
}

topic_alpha <- function(df, topic_name) {
  if (topic_count(df, topic_name) == 0){
    return (0)
  }
  all_units_numeric <- mutate(df, across(all_of(present_coders), ~ as.numeric(factor(.))))
  result <- all_units_numeric[all_units_numeric$topic == topic_name, ] |>
  select(all_of(present_coders)) |>
    # Prepare numeric data as a matrix for Krippendorff calculation
    as.matrix() |>
    t() |>
    irr::kripp.alpha(method="nominal") 
  return(result$value)
}


```

## Coder Reliability

The overall reliability across all coded units is a Krippendorff's alpha of **`r round(overall_kripp_alpha$value, 2)`**

```{r}
#| echo: false
#| messages: false
#| warnings: false
#| output: true
#| label: plot-alpha

# #| fig.cap: "Reliability scores between coders"

plot_pairwise_kripp_alpha(pairwise_kripp_alpha)

```

## Topic Reliability

The following table reports the progression of issues coded and the current reliability (calculated using Krippendorff's alpha) for each topic.

```{r results='asis', echo=FALSE}

topic_status <- function(df, total_df){
  topic_info <- tibble(topic_name = character(), completed_count = numeric(), total_count = numeric(), percentage_done = character(), reliability_α = numeric())  # Initialize as character to hold the formatted percentage
  
  for (topic_name in unique(total_df$topic)) {
    completed_count <- topic_count(df, topic_name)
    total_count <- topic_count(total_df, topic_name)
    topic_alpha <- round(topic_alpha(df, topic_name), 2)
    
    # Calculate percentage and format it directly
    percentage_done <- paste0(round(100 * completed_count / total_count, 1), "%")
    
    # Add a new row with all necessary data
    topic_info <- topic_info |>
      add_row(
        topic_name = topic_name, 
        completed_count = completed_count, 
        total_count = total_count,
        percentage_done = percentage_done,
        reliability_α = topic_alpha
      )
  }
  
  return(topic_info)
}

topic_info <- topic_status(all_units, gpt_issues_all)

# Define custom column names
custom_headers <- c("Topic", "Completed", "Total", "Percentage Done", "Reliability (α)")

# Use kable and kableExtra for enhanced table customization
kable(topic_info, format = "html", col.names = custom_headers, caption = "Topic Status Overview", align ='c') |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)
```

